// automatically generated by rust-bindgen

/// A group that associates JavaScript contexts with one another.
/// Contexts in the same group may share and exchange JavaScript objects.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContextGroup([u8; 0]);

/// A group that associates JavaScript contexts with one another.
/// Contexts in the same group may share and exchange JavaScript objects.
pub type JSContextGroupRef = *const OpaqueJSContextGroup;

/// A JavaScript execution context. Holds the global object and
/// other execution state.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContext([u8; 0]);

/// A JavaScript execution context. Holds the global object and
/// other execution state.
pub type JSContextRef = *const OpaqueJSContext;

/// A global JavaScript execution context.
/// A `JSGlobalContext` is a `JSContext`.
pub type JSGlobalContextRef = *mut OpaqueJSContext;

/// A UTF16 character buffer. The fundamental string representation
/// in JavaScript.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSString([u8; 0]);

/// A UTF16 character buffer. The fundamental string representation
/// in JavaScript.
pub type JSStringRef = *mut OpaqueJSString;

/// A JavaScript class.
/// Used with `JSObjectMake` to construct objects with custom behavior.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSClass([u8; 0]);

/// A JavaScript class.
/// Used with `JSObjectMake` to construct objects with custom behavior.
pub type JSClassRef = *mut OpaqueJSClass;

/// An array of JavaScript property names.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameArray([u8; 0]);

/// An array of JavaScript property names.
pub type JSPropertyNameArrayRef = *mut OpaqueJSPropertyNameArray;

/// An ordered set used to collect the names of
/// a JavaScript object's properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameAccumulator([u8; 0]);

/// An ordered set used to collect the names of
/// a JavaScript object's properties.
pub type JSPropertyNameAccumulatorRef = *mut OpaqueJSPropertyNameAccumulator;

/// A function used to deallocate bytes passed to a Typed Array constructor.
/// The function should take two arguments. The first is a pointer to
/// the bytes that were originally passed to the Typed Array constructor.
/// The second is a pointer to additional information desired at the time
/// the bytes are to be freed.
pub type JSTypedArrayBytesDeallocator =
    ::std::option::Option<
        unsafe extern "C" fn(bytes: *mut ::std::os::raw::c_void,
                             deallocatorContext: *mut ::std::os::raw::c_void),
    >;

/// A JavaScript value.
/// The base type for all JavaScript values, and polymorphic functions on them.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSValue([u8; 0]);

/// A JavaScript value.
/// The base type for all JavaScript values, and polymorphic functions on them.
pub type JSValueRef = *const OpaqueJSValue;

/// A JavaScript object. A JSObject is a JSValue.
pub type JSObjectRef = *mut OpaqueJSValue;

extern "C" {
    /// Evaluates a string of JavaScript.
    ///
    /// * `ctx`: The execution context to use.
    /// * `script`: A `JSString` containing the script to evaluate.
    /// * `thisObject`: The object to use as `this`, or `NULL` to
    ///   use the global object as `this`.
    /// * `sourceURL`: A `JSString` containing a URL for the script's
    ///   source file. This is used by debuggers and when reporting
    ///   exceptions. Pass `NULL` if you do not care to include source
    ///   file information.
    /// * `startingLineNumber`: An integer value specifying the script's
    ///   starting line number in the file located at `sourceURL`. This
    ///   is only used when reporting exceptions. The value is one-based,
    ///   so the first line is line `1` and invalid values are clamped
    ///   to `1`.
    /// * `exception`: A pointer to a `JSValueRef` in which to store an
    ///   exception, if any. Pass `NULL` if you do not care to store an
    ///   exception.
    ///
    /// The `JSValue` that results from evaluating script, or `NULL` if an exception is thrown.
    pub fn JSEvaluateScript(
        ctx: JSContextRef,
        script: JSStringRef,
        thisObject: JSObjectRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSValueRef;

    /// Checks for syntax errors in a string of JavaScript.
    ///
    /// * `ctx`: The execution context to use.
    /// * `script`: A `JSString` containing the script to check for
    ///   syntax errors.
    /// * `sourceURL`: A `JSString` containing a URL for the script's
    ///   source file. This is only used when reporting exceptions.
    ///   Pass `NULL` if you do not care to include source file
    ///   information in exceptions.
    /// * `startingLineNumber`: An integer value specifying the script's
    ///   starting line number in the file located at `sourceURL`. This
    ///   is only used when reporting exceptions. The value is one-based,
    ///   so the first line is line `1` and invalid values are clamped
    ///   to `1`.
    /// * `exception`: A pointer to a `JSValueRef` in which to store a
    ///   syntax error exception, if any. Pass `NULL` if you do not care
    ///   to store a syntax error exception.
    ///
    /// Returns `true` if the script is syntactically correct, otherwise `false`.
    pub fn JSCheckScriptSyntax(
        ctx: JSContextRef,
        script: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> bool;

    /// Performs a JavaScript garbage collection.
    ///
    /// JavaScript values that are on the machine stack, in a register,
    /// protected by `JSValueProtect`, set as the global object of an
    /// execution context, or reachable from any such value will not
    /// be collected.
    ///
    /// During JavaScript execution, you are not required to call this
    /// function; the JavaScript engine will garbage collect as needed.
    /// JavaScript values created within a context group are automatically
    /// destroyed when the last reference to the context group is released.
    ///
    /// * `ctx`: The execution context to use.
    pub fn JSGarbageCollect(ctx: JSContextRef);
}

/// A constant identifying the type of a `JSValue`.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JSType {
    /// The unique `undefined` value.
    kJSTypeUndefined = 0,
    /// The unique `null` value.
    kJSTypeNull = 1,
    /// A primitive boolean value, one of `true` or `false`.
    kJSTypeBoolean = 2,
    /// A primitive number value.
    kJSTypeNumber = 3,
    /// A primitive string value.
    kJSTypeString = 4,
    /// An object value (meaning that this `JSValueRef` is a `JSObjectRef`).
    kJSTypeObject = 5,
}

/// A constant identifying the Typed Array type of a `JSObjectRef`.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JSTypedArrayType {
    /// `Int8Array`
    kJSTypedArrayTypeInt8Array = 0,
    /// `Int16Array`
    kJSTypedArrayTypeInt16Array = 1,
    /// `Int32Array`
    kJSTypedArrayTypeInt32Array = 2,
    /// `Uint8Array`
    kJSTypedArrayTypeUint8Array = 3,
    /// `Uint8ClampedArray`
    kJSTypedArrayTypeUint8ClampedArray = 4,
    /// `Uint16Array`
    kJSTypedArrayTypeUint16Array = 5,
    /// `Uint32Array`
    kJSTypedArrayTypeUint32Array = 6,
    /// `Float32Array`
    kJSTypedArrayTypeFloat32Array = 7,
    /// `Float64Array`
    kJSTypedArrayTypeFloat64Array = 8,
    /// `ArrayBuffer`
    kJSTypedArrayTypeArrayBuffer = 9,
    /// Not a Typed Array
    kJSTypedArrayTypeNone = 10,
}

extern "C" {
    /// Returns a JavaScript value's type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` whose type you want to obtain.
    ///
    /// Returns a value of type `JSType` that identifies `value`'s type.
    pub fn JSValueGetType(ctx: JSContextRef, arg1: JSValueRef) -> JSType;

    /// Tests whether a JavaScript value's type is the `undefined` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value`'s type is the `undefined` type, otherwise `false`.
    pub fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value's type is the `null` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value`'s type is the `null` type, otherwise `false`.
    pub fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value's type is the `boolean` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value`'s type is the `boolean` type, otherwise `false`.
    pub fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value's type is the `number` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value`'s type is the `number` type, otherwise `false`.
    pub fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value's type is the `string` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value`'s type is the `string` type, otherwise `false`.
    pub fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value's type is the `object` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value`'s type is the `object` type, otherwise `false`.
    pub fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value is an `object` with a given class in its class chain.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    /// * `jsClass`: The `JSClass` to test against.
    ///
    /// Returns `true` if `value` is an `object` and has `jsClass` in its
    /// class chain, otherwise `false`.
    pub fn JSValueIsObjectOfClass(
        ctx: JSContextRef,
        value: JSValueRef,
        jsClass: JSClassRef,
    ) -> bool;

    /// Tests whether a JavaScript value is an `array`.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value` is an `array`, otherwise `false`.
    pub fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Tests whether a JavaScript value is a `date`.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to test.
    ///
    /// Returns `true` if `value` is a `date`, otherwise `false`.
    pub fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Returns a JavaScript value's Typed Array type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` whose Typed Array type to return.
    /// * `exception`: A pointer to a `JSValueRef` in which to store
    ///   an exception, if any. Pass `NULL` if you do not care to
    ///   store an exception.
    ///
    /// Returns a value of type `JSTypedArrayType` that identifies
    /// value's Typed Array type, or `kJSTypedArrayTypeNone` if the
    /// value is not a Typed Array object.
    pub fn JSValueGetTypedArrayType(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType;

    /// Tests whether two JavaScript values are equal, as compared by the JS `==` operator.
    ///
    /// * `ctx`: The execution context to use.
    /// * `a`: The first value to test.
    /// * `b`: The second value to test.
    /// * `exception`: A pointer to a `JSValueRef` in which to
    ///   store an exception, if any. Pass `NULL` if you do
    ///   not care to store an exception.
    ///
    /// Returns `true` if the two values are equal, `false` if
    /// they are not equal or an exception is thrown.
    pub fn JSValueIsEqual(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;

    /// Tests whether two JavaScript values are strict equal, as compared
    /// by the JS `===` operator.
    ///
    /// * `ctx`: The execution context to use.
    /// * `a`: The first value to test.
    /// * `b`: The second value to test.
    ///
    /// Returns `true` if the two values are strict equal, otherwise `false`.
    pub fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;

    /// Tests whether a JavaScript value is an object constructed by a
    /// given constructor, as compared by the JS `instanceof` operator.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The JSValue to test.
    /// * `constructor`: The constructor to test against.
    /// * `exception`: A pointer to a `JSValueRef` in which to
    ///   store an exception, if any. Pass `NULL` if you do
    ///   not care to store an exception.
    ///
    /// Returns `true` if value is an object constructed by constructor,
    /// as compared by the JS `instanceof` operator, otherwise `false`.
    pub fn JSValueIsInstanceOfConstructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;

    /// Creates a JavaScript value of the `undefined` type.
    ///
    /// * `ctx`: The execution context to use.
    ///
    /// Returns the unique `undefined` value.
    pub fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;

    /// Creates a JavaScript value of the `null` type.
    ///
    /// * `ctx`: The execution context to use.
    ///
    /// Returns the unique `null` value.
    pub fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;

    /// Creates a JavaScript value of the `boolean` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `boolean`: The `bool` to assign to the newly created `JSValue`.
    ///
    /// Returns a `JSValue` of the `boolean` type, representing the value of `boolean`.
    pub fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;

    /// Creates a JavaScript value of the `number` type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `number`: The `f64` to assign to the newly created `JSValue`.
    ///
    /// Returns a `JSValue` of the `number` type, representing the value of `number`.
    pub fn JSValueMakeNumber(ctx: JSContextRef, number: f64) -> JSValueRef;

    /// Creates a JavaScript value of the string type.
    ///
    /// * `ctx`: The execution context to use.
    /// * `string`: The `JSString` to assign to the newly created
    ///   JSValue`. The newly created `JSValue` retains string, and
    ///   releases it upon garbage collection.
    ///
    /// Returns a `JSValue` of the `string` type, representing the value of `string`.
    pub fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;

    /// Creates a JavaScript value from a JSON formatted string.
    ///
    /// * `ctx`: The execution context to use.
    /// * `string`: The `JSString` containing the JSON string to be parsed.
    ///
    /// Returns a `JSValue` containing the parsed value, or `NULL` if the input is invalid.
    pub fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;

    /// Creates a JavaScript string containing the JSON serialized representation of a JS value.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The value to serialize.
    /// * `indent`: The number of spaces to indent when nesting.
    ///   If `0`, the resulting JSON will not contains newlines.
    ///   The size of the indent is clamped to `10` spaces.
    /// * `exception`: A pointer to a `JSValueRef` in which to
    ///   store an exception, if any. Pass `NULL` if you do not
    ///   care to store an exception.
    ///
    /// Returns a `JSString` with the result of serialization, or `NULL` if an exception is thrown.
    pub fn JSValueCreateJSONString(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef;

    /// Converts a JavaScript value to boolean and returns the resulting boolean.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The JSValue to convert.
    ///
    /// Returns the boolean result of conversion.
    pub fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;

    /// Converts a JavaScript value to number and returns the resulting number.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to convert.
    /// * `exception`: A pointer to a `JSValueRef` in which to store an
    ///   exception, if any. Pass `NULL` if you do not care to store an
    ///   exception.
    ///
    /// Returns the numeric result of conversion, or `NaN` if an exception is thrown.
    pub fn JSValueToNumber(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> f64;

    /// Converts a JavaScript value to string and copies the result into a JavaScript string.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to convert.
    /// * `exception`:  A pointer to a `JSValueRef` in which to store an
    ///   exception, if any. Pass `NULL` if you do not care to store an
    ///   exception.
    ///
    /// Returns a `JSString` with the result of conversion, or `NULL`
    /// if an exception is thrown. Ownership follows the Create Rule.
    pub fn JSValueToStringCopy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef;

    /// Converts a JavaScript value to object and returns the resulting object.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to convert.
    /// * `exception`: A pointer to a `JSValueRef` in which to store
    ///   an exception, if any. Pass `NULL` if you do not care to store
    ///   an exception.
    ///
    /// Returns the `JSObject` result of conversion, or `NULL` if
    /// an exception is thrown.
    pub fn JSValueToObject(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;

    /// Protects a JavaScript value from garbage collection.
    ///
    /// Use this method when you want to store a `JSValue` in a
    /// global or on the heap, where the garbage collector will
    /// not be able to discover your reference to it.
    ///
    /// A value may be protected multiple times and must be
    /// unprotected an equal number of times before becoming
    /// eligible for garbage collection.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to protect.
    pub fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);

    /// Unprotects a JavaScript value from garbage collection.
    ///
    /// A value may be protected multiple times and must be unprotected
    /// an equal number of times before becoming eligible for garbage
    /// collection.
    ///
    /// * `ctx`: The execution context to use.
    /// * `value`: The `JSValue` to unprotect.
    pub fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
}
/// A set of `JSPropertyAttribute`s.
///
/// Combine multiple attributes by logically ORing them together.
pub type JSPropertyAttributes = ::std::os::raw::c_uint;

/// A set of `JSClassAttribute`s.
///
/// Combine multiple attributes by logically ORing them together.
pub type JSClassAttributes = ::std::os::raw::c_uint;

/// The callback invoked when an object is first created.
///
/// * `ctx`: The execution context to use.
/// * `object`: The `JSObject` being created.
///
/// Unlike the other object callbacks, the initialize callback is
/// called on the least derived class (the parent class) first,
/// and the most derived class last.
pub type JSObjectInitializeCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef)>;

/// The callback invoked when an object is finalized (prepared
/// for garbage collection). An object may be finalized on any thread.
///
/// * `object`: The `JSObject` being finalized.
///
/// The finalize callback is called on the most derived class
/// first, and the least derived class (the parent class) last.
///
/// You must not call any function that may cause a garbage
/// collection or an allocation of a garbage collected object
/// from within a `JSObjectFinalizeCallback`. This includes
/// all functions that have a `JSContextRef` parameter.
pub type JSObjectFinalizeCallback =
    ::std::option::Option<unsafe extern "C" fn(object: JSObjectRef)>;

pub type JSObjectHasPropertyCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             object: JSObjectRef,
                             propertyName: JSStringRef)
                             -> bool,
    >;
pub type JSObjectGetPropertyCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             object: JSObjectRef,
                             propertyName: JSStringRef,
                             exception: *mut JSValueRef)
                             -> *const OpaqueJSValue,
    >;
pub type JSObjectSetPropertyCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             object: JSObjectRef,
                             propertyName: JSStringRef,
                             value: JSValueRef,
                             exception: *mut JSValueRef)
                             -> bool,
    >;
pub type JSObjectDeletePropertyCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             object: JSObjectRef,
                             propertyName: JSStringRef,
                             exception: *mut JSValueRef)
                             -> bool,
    >;
pub type JSObjectGetPropertyNamesCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             object: JSObjectRef,
                             propertyNames: JSPropertyNameAccumulatorRef),
    >;
pub type JSObjectCallAsFunctionCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             function: JSObjectRef,
                             thisObject: JSObjectRef,
                             argumentCount: usize,
                             arguments: *const JSValueRef,
                             exception: *mut JSValueRef)
                             -> *const OpaqueJSValue,
    >;
pub type JSObjectCallAsConstructorCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             constructor: JSObjectRef,
                             argumentCount: usize,
                             arguments: *const JSValueRef,
                             exception: *mut JSValueRef)
                             -> *mut OpaqueJSValue,
    >;
pub type JSObjectHasInstanceCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             constructor: JSObjectRef,
                             possibleInstance: JSValueRef,
                             exception: *mut JSValueRef)
                             -> bool,
    >;
pub type JSObjectConvertToTypeCallback =
    ::std::option::Option<
        unsafe extern "C" fn(ctx: JSContextRef,
                             object: JSObjectRef,
                             type_: JSType,
                             exception: *mut JSValueRef)
                             -> *const OpaqueJSValue,
    >;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSStaticValue {
    pub name: *const ::std::os::raw::c_char,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub attributes: JSPropertyAttributes,
}
#[test]
fn bindgen_test_layout_JSStaticValue() {
    assert_eq!(
        ::std::mem::size_of::<JSStaticValue>(),
        32usize,
        concat!("Size of: ", stringify!(JSStaticValue))
    );
    assert_eq!(
        ::std::mem::align_of::<JSStaticValue>(),
        8usize,
        concat!("Alignment of ", stringify!(JSStaticValue))
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticValue)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticValue)).getProperty as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(getProperty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticValue)).setProperty as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(setProperty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticValue)).attributes as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticValue),
            "::",
            stringify!(attributes)
        )
    );
}
impl Clone for JSStaticValue {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSStaticFunction {
    pub name: *const ::std::os::raw::c_char,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub attributes: JSPropertyAttributes,
}
#[test]
fn bindgen_test_layout_JSStaticFunction() {
    assert_eq!(
        ::std::mem::size_of::<JSStaticFunction>(),
        24usize,
        concat!("Size of: ", stringify!(JSStaticFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<JSStaticFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(JSStaticFunction))
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticFunction)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticFunction),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticFunction)).callAsFunction as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticFunction),
            "::",
            stringify!(callAsFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSStaticFunction)).attributes as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSStaticFunction),
            "::",
            stringify!(attributes)
        )
    );
}
impl Clone for JSStaticFunction {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSClassDefinition {
    pub version: ::std::os::raw::c_int,
    pub attributes: JSClassAttributes,
    pub className: *const ::std::os::raw::c_char,
    pub parentClass: JSClassRef,
    pub staticValues: *const JSStaticValue,
    pub staticFunctions: *const JSStaticFunction,
    pub initialize: JSObjectInitializeCallback,
    pub finalize: JSObjectFinalizeCallback,
    pub hasProperty: JSObjectHasPropertyCallback,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub deleteProperty: JSObjectDeletePropertyCallback,
    pub getPropertyNames: JSObjectGetPropertyNamesCallback,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub callAsConstructor: JSObjectCallAsConstructorCallback,
    pub hasInstance: JSObjectHasInstanceCallback,
    pub convertToType: JSObjectConvertToTypeCallback,
}
#[test]
fn bindgen_test_layout_JSClassDefinition() {
    assert_eq!(
        ::std::mem::size_of::<JSClassDefinition>(),
        128usize,
        concat!("Size of: ", stringify!(JSClassDefinition))
    );
    assert_eq!(
        ::std::mem::align_of::<JSClassDefinition>(),
        8usize,
        concat!("Alignment of ", stringify!(JSClassDefinition))
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).version as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).attributes as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).className as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(className)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).parentClass as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(parentClass)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).staticValues as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(staticValues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).staticFunctions as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(staticFunctions)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).initialize as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).finalize as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).hasProperty as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(hasProperty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).getProperty as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(getProperty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).setProperty as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(setProperty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).deleteProperty as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(deleteProperty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).getPropertyNames as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(getPropertyNames)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).callAsFunction as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(callAsFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).callAsConstructor as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(callAsConstructor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).hasInstance as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(hasInstance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const JSClassDefinition)).convertToType as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(JSClassDefinition),
            "::",
            stringify!(convertToType)
        )
    );
}
impl Clone for JSClassDefinition {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    /// Creates a JavaScript class suitable for use with `JSObjectMake`.
    ///
    /// * `definition`: A `JSClassDefinition` that defines the class.
    ///
    /// Returns a `JSClass` with the given definition. Ownership follows
    /// the Create Rule.
    pub fn JSClassCreate(definition: *const JSClassDefinition) -> JSClassRef;

    /// Retains a JavaScript class.
    ///
    /// `jsClass`: The `JSClass` to retain.
    ///
    /// Returns a `JSClass` that is the same as `jsClass`.
    pub fn JSClassRetain(jsClass: JSClassRef) -> JSClassRef;

    /// Releases a JavaScript class.
    ///
    /// `jsClass`: The `JSClass` to release.
    pub fn JSClassRelease(jsClass: JSClassRef);

    /// Creates a JavaScript object.
    ///
    /// The default object class does not allocate storage for private data,
    /// so you must provide a non-`NULL` `jsClass` to `JSObjectMake` if you
    /// want your object to be able to store private data.
    ///
    /// `data` is set on the created object before the initialize methods in
    /// its class chain are called. This enables the initialize methods to
    /// retrieve and manipulate data through `JSObjectGetPrivate`.
    ///
    /// * `ctx`: The execution context to use.
    /// * `jsClass`: The `JSClass` to assign to the object. Pass `NULL` to use
    ///   the default object class.
    /// * `data`: A `void*` to set as the object's private data.
    ///    Pass NULL to specify no private data.
    ///
    /// Returns a `JSObject` with the given class and private data.
    pub fn JSObjectMake(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        data: *mut ::std::os::raw::c_void,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeFunctionWithCallback(
        ctx: JSContextRef,
        name: JSStringRef,
        callAsFunction: JSObjectCallAsFunctionCallback,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeConstructor(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        callAsConstructor: JSObjectCallAsConstructorCallback,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeArray(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeDate(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeError(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeRegExp(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeFunction(
        ctx: JSContextRef,
        name: JSStringRef,
        parameterCount: ::std::os::raw::c_uint,
        parameterNames: *const JSStringRef,
        body: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectGetPrototype(ctx: JSContextRef, object: JSObjectRef) -> JSValueRef;
}
extern "C" {
    pub fn JSObjectSetPrototype(ctx: JSContextRef, object: JSObjectRef, value: JSValueRef);
}
extern "C" {
    pub fn JSObjectHasProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
    ) -> bool;
}
extern "C" {
    pub fn JSObjectGetProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    pub fn JSObjectSetProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    pub fn JSObjectDeleteProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    pub fn JSObjectGetPropertyAtIndex(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    pub fn JSObjectSetPropertyAtIndex(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        value: JSValueRef,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    pub fn JSObjectGetPrivate(object: JSObjectRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn JSObjectSetPrivate(object: JSObjectRef, data: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn JSObjectIsFunction(ctx: JSContextRef, object: JSObjectRef) -> bool;
}
extern "C" {
    pub fn JSObjectCallAsFunction(
        ctx: JSContextRef,
        object: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    pub fn JSObjectIsConstructor(ctx: JSContextRef, object: JSObjectRef) -> bool;
}
extern "C" {
    pub fn JSObjectCallAsConstructor(
        ctx: JSContextRef,
        object: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectCopyPropertyNames(
        ctx: JSContextRef,
        object: JSObjectRef,
    ) -> JSPropertyNameArrayRef;
}
extern "C" {
    pub fn JSPropertyNameArrayRetain(array: JSPropertyNameArrayRef) -> JSPropertyNameArrayRef;
}
extern "C" {
    pub fn JSPropertyNameArrayRelease(array: JSPropertyNameArrayRef);
}
extern "C" {
    pub fn JSPropertyNameArrayGetCount(array: JSPropertyNameArrayRef) -> usize;
}
extern "C" {
    pub fn JSPropertyNameArrayGetNameAtIndex(
        array: JSPropertyNameArrayRef,
        index: usize,
    ) -> JSStringRef;
}
extern "C" {
    pub fn JSPropertyNameAccumulatorAddName(
        accumulator: JSPropertyNameAccumulatorRef,
        propertyName: JSStringRef,
    );
}
extern "C" {

    /// Creates a JavaScript context group.
    ///
    /// `JSContextGroup` associates JavaScript contexts with one another.
    /// Contexts in the same group may share and exchange JavaScript
    /// objects. Sharing and/or exchanging JavaScript objects between
    /// contexts in different groups will produce undefined behavior.
    /// When objects from the same context group are used in multiple threads,
    /// explicit synchronization is required.
    ///
    /// Returns the created `JSContextGroup`.
    pub fn JSContextGroupCreate() -> JSContextGroupRef;

    /// Retains a JavaScript context group.
    ///
    /// * `group`: The `JSContextGroup` to retain.
    ///
    /// Returns a `JSContextGroup` that is the same as group.
    pub fn JSContextGroupRetain(group: JSContextGroupRef) -> JSContextGroupRef;

    /// Releases a JavaScript context group.
    ///
    /// * `group`: The `JSContextGroup` to release.
    pub fn JSContextGroupRelease(group: JSContextGroupRef);
}
extern "C" {
    /// Creates a global JavaScript execution context.
    ///
    /// `JSGlobalContextCreate` allocates a global object and populates
    /// it with all the built-in JavaScript objects, such as `Object`,
    /// `Function`, `String`, and `Array`.
    ///
    /// In WebKit version 4.0 and later, the context is created in a
    /// unique context group. Therefore, scripts may execute in it
    /// concurrently with scripts executing in other contexts. However,
    /// you may not use values created in the context in other contexts.
    ///
    /// * `globalObjectClass`: The class to use when creating the global
    ///   object. Pass `NULL` to use the default object class.
    ///
    /// Returns a `JSGlobalContext` with a global object of
    /// class `globalObjectClass`.
    pub fn JSGlobalContextCreate(globalObjectClass: JSClassRef) -> JSGlobalContextRef;

    /// Creates a global JavaScript execution context in the context
    /// group provided.
    ///
    /// `JSGlobalContextCreateInGroup` allocates a global object and
    /// populates it with all the built-in JavaScript objects, such as
    /// `Object`, `Function`, `String`, and `Array`.
    ///
    /// * `group`: The context group to use. The created global context
    ///   retains the group.  Pass `NULL` to create a unique group for
    ///   the context.
    /// * `globalObjectClass`: The class to use when creating the global
    ///   object. Pass NULL to use the default object class.
    ///
    /// Returns a `JSGlobalContext` with a global object of class
    /// `globalObjectClass` and a context group equal to `group`.
    pub fn JSGlobalContextCreateInGroup(
        group: JSContextGroupRef,
        globalObjectClass: JSClassRef,
    ) -> JSGlobalContextRef;

    /// Retains a global JavaScript execution context.
    ///
    /// * `ctx`: The JSGlobalContext to retain.
    ///
    /// Returns a `JSGlobalContext` that is the same as `ctx`.
    pub fn JSGlobalContextRetain(ctx: JSGlobalContextRef) -> JSGlobalContextRef;

    /// Releases a global JavaScript execution context.
    ///
    /// * `ctx` The `JSGlobalContext` to release.
    pub fn JSGlobalContextRelease(ctx: JSGlobalContextRef);

    /// Gets the global object of a JavaScript execution context.
    ///
    /// * `ctx` The `JSContext` whose global object you want to get.
    ///
    /// Returns `ctx`'s global object.
    pub fn JSContextGetGlobalObject(ctx: JSContextRef) -> JSObjectRef;

    /// Gets the context group to which a JavaScript execution context belongs.
    ///
    /// * `ctx`: The `JSContext` whose group you want to get.
    ///
    /// Returns `ctx`'s group.
    pub fn JSContextGetGroup(ctx: JSContextRef) -> JSContextGroupRef;

    /// Gets the global context of a JavaScript execution context.
    ///
    /// * `ctx`: The `JSContext` whose global context you want to get.
    ///
    /// Returns `ctx`'s global context.
    pub fn JSContextGetGlobalContext(ctx: JSContextRef) -> JSGlobalContextRef;

    /// Gets a copy of the name of a context.
    ///
    /// A `JSGlobalContext`'s name is exposed for remote debugging
    /// to make it easier to identify the context you would like to
    /// attach to.
    ///
    /// * `ctx`: The `JSGlobalContext` whose name you want to get.
    ///
    /// Returns the name for `ctx`.
    pub fn JSGlobalContextCopyName(ctx: JSGlobalContextRef) -> JSStringRef;

    /// Sets the remote debugging name for a context.
    ///
    /// * `ctx`: The `JSGlobalContext` that you want to name.
    /// * `name`: The remote debugging name to set on `ctx`.
    pub fn JSGlobalContextSetName(ctx: JSGlobalContextRef, name: JSStringRef);
}
/// A UTF-16 code unit.
///
/// One, or a sequence of two, can encode any Unicode character. As
/// with all scalar types, endianness depends on the underlying
/// architecture.
pub type JSChar = ::std::os::raw::c_ushort;
extern "C" {
    /// Creates a JavaScript string from a buffer of Unicode characters.
    ///
    /// * `chars`: The buffer of Unicode characters to copy into the
    ///   new `JSString`.
    /// * `numChars`: The number of characters to copy from the buffer
    ///   pointed to by `chars`.
    ///
    /// Returns a `JSString` containing `chars`. Ownership follows the
    /// Create Rule.
    pub fn JSStringCreateWithCharacters(chars: *const JSChar, numChars: usize) -> JSStringRef;

    /// Creates a JavaScript string from a null-terminated UTF8 string.
    ///
    /// * `string`: The null-terminated UTF8 string to copy into the
    ///   new `JSString`.
    ///
    /// Returns a `JSString` containing `string`. Ownership follows the
    /// Create Rule.
    pub fn JSStringCreateWithUTF8CString(string: *const ::std::os::raw::c_char) -> JSStringRef;

    /// Retains a JavaScript string.
    ///
    /// * `string`: The `JSString` to retain.
    ///
    /// Returns a `JSString` that is the same as `string`.
    pub fn JSStringRetain(string: JSStringRef) -> JSStringRef;

    /// Releases a JavaScript string.
    ///
    /// * `string`: The `JSString` to release.
    pub fn JSStringRelease(string: JSStringRef);

    /// Returns the number of Unicode characters in a JavaScript string.
    ///
    /// * `string`: The `JSString` whose length (in Unicode characters)
    ///   you want to know.
    ///
    /// Returns the number of Unicode characters stored in `string`.
    pub fn JSStringGetLength(string: JSStringRef) -> usize;

    /// Returns a pointer to the Unicode character buffer that
    /// serves as the backing store for a JavaScript string.
    ///
    /// * `string`: The `JSString` whose backing store you want to access.
    ///
    /// Returns a pointer to the Unicode character buffer that serves
    /// as `string`'s backing store, which will be deallocated when
    /// `string` is deallocated.
    pub fn JSStringGetCharactersPtr(string: JSStringRef) -> *const JSChar;

    /// Returns the maximum number of bytes a JavaScript string will
    /// take up if converted into a null-terminated UTF8 string.
    ///
    /// * `string`: The `JSString` whose maximum converted size (in bytes)
    ///   you want to know.
    ///
    /// Returns the maximum number of bytes that could be required to
    /// convert `string` into a null-terminated UTF8 string. The number
    /// of bytes that the conversion actually ends up requiring could
    /// be less than this, but never more.
    pub fn JSStringGetMaximumUTF8CStringSize(string: JSStringRef) -> usize;

    /// Converts a JavaScript string into a null-terminated UTF8 string,
    /// and copies the result into an external byte buffer.
    ///
    /// * `string`: The source `JSString`.
    /// * `buffer`: The destination byte buffer into which to copy a
    ///   null-terminated UTF8 representation of `string`. On return,
    ///   `buffer` contains a UTF8 string representation of `string`. If
    ///   `bufferSize` is too small, `buffer` will contain only
    ///   partial results. If `buffer` is not at least `bufferSize`
    ///   bytes in size, behavior is undefined.
    /// * `bufferSize`: The size of the external buffer in bytes.
    ///
    /// Returns the number of bytes written into buffer (including the null-terminator byte).
    pub fn JSStringGetUTF8CString(
        string: JSStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> usize;

    /// Tests whether two JavaScript strings match.
    ///
    /// * `a`: The first `JSString` to test.
    /// * `b`: The second `JSString` to test.
    ///
    /// Returns `true` if the two strings match, otherwise `false`.
    pub fn JSStringIsEqual(a: JSStringRef, b: JSStringRef) -> bool;

    /// Tests whether a JavaScript string matches a null-terminated
    /// UTF8 string.
    ///
    /// * `a`: The `JSString` to test.
    /// * `b`: The null-terminated UTF8 string to test.
    ///
    /// Returns `true` if the two strings match, otherwise `false`.
    pub fn JSStringIsEqualToUTF8CString(a: JSStringRef, b: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn JSObjectMakeTypedArray(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeTypedArrayWithBytesNoCopy(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeTypedArrayWithArrayBuffer(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeTypedArrayWithArrayBufferAndOffset(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        byteOffset: usize,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectGetTypedArrayBytesPtr(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn JSObjectGetTypedArrayLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    pub fn JSObjectGetTypedArrayByteLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    pub fn JSObjectGetTypedArrayByteOffset(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    pub fn JSObjectGetTypedArrayBuffer(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectMakeArrayBufferWithBytesNoCopy(
        ctx: JSContextRef,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    pub fn JSObjectGetArrayBufferBytesPtr(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn JSObjectGetArrayBufferByteLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
